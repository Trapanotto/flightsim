<!DOCTYPE html>
<html>
<head>
    <title>Trapanotto Flight Simulator</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            line-height: 1.4;
        }
        .touch-controls {
            position: fixed;
            pointer-events: none;
        }
        .touch-button {
            width: 80px;
            height: 80px;
            background: rgba(255,255,255,0.4);
            border: 2px solid white;
            border-radius: 50%;
            color: white;
            font-size: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            pointer-events: auto;
            cursor: pointer;
            touch-action: none;
        }
        #throttle-controls {
            position: fixed;
            right: 40px;
            bottom: 40px;
        }
        #direction-controls {
            position: fixed;
            left: 40px;
            bottom: 40px;
        }
        /* Specific button positions for direction controls */
        #pitch-up {
            position: absolute;
            bottom: 160px;
            left: 80px;
        }
        
        #turn-left {
            position: absolute;
            bottom: 80px;
            left: 0;
        }
        
        #turn-right {
            position: absolute;
            bottom: 80px;
            left: 160px;
        }
        
        #pitch-down {
            position: absolute;
            bottom: 0;
            left: 80px;
        }
        
        /* Specific button positions for throttle controls */
        #throttle-up {
            position: absolute;
            bottom: 120px;
            right: 40px;
        }
        
        #throttle-down {
            position: absolute;
            bottom: 20px;
            right: 40px;
        }
        @media (max-width: 768px) {
            .touch-button {
                width: 65px;
                height: 65px;
                font-size: 26px;
            }
            /* Adjust positions for smaller screens */
            #pitch-up { 
                bottom: 130px;
                left: 65px;
            }
            #turn-left {
                bottom: 65px;
                left: 0;
            }
            #turn-right {
                bottom: 65px;
                left: 130px;
            }
            #pitch-down {
                bottom: 0;
                left: 65px;
            }
            #throttle-up {
                bottom: 100px;
                right: 30px;
            }
            #throttle-down {
                bottom: 15px;
                right: 30px;
            }
        }
        @media (max-width: 480px) {
            .touch-button {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            /* Adjust positions for mobile screens */
            #pitch-up {
                bottom: 100px;
                left: 50px;
            }
            #turn-left {
                bottom: 50px;
                left: 0;
            }
            #turn-right {
                bottom: 50px;
                left: 100px;
            }
            #pitch-down {
                bottom: 0;
                left: 50px;
            }
            #throttle-up {
                bottom: 80px;
                right: 20px;
            }
            #throttle-down {
                bottom: 10px;
                right: 20px;
            }
        }
        #shoot-button {
            position: fixed;
            right: 40px;
            top: 40px;
            width: 100px;
            height: 100px;
            background: rgba(255, 100, 100, 0.4);
            border: 2px solid #ff6666;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            cursor: pointer;
            touch-action: none;
        }
        @media (max-width: 768px) {
            #shoot-button {
                width: 80px;
                height: 80px;
                font-size: 20px;
                right: 30px;
                top: 30px;
            }
        }
        @media (max-width: 480px) {
            #shoot-button {
                width: 60px;
                height: 60px;
                font-size: 16px;
                right: 20px;
                top: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="hud">
        Speed: <span id="speed">0</span> km/h<br>
        Altitude: <span id="altitude">0</span> m<br>
        <br>
        Controls:<br>
        W/S - Throttle Up/Down<br>
        ↑/↓ - Pitch (pull back/DOWN to take off)<br>
        ←/→ - Turn Left/Right (Roll when airborne)<br>
        SPACE - Fire Weapons<br>
        <div id="takeoff-message" style="display: none; color: #ff0; font-size: 1.2em; margin-top: 10px; font-weight: bold;">TAKEOFF</div>
    </div>
    <div id="shoot-button" class="touch-button">FIRE</div>
    <div id="throttle-controls" class="touch-controls">
        <div class="touch-button" id="throttle-up">W</div>
        <div class="touch-button" id="throttle-down">S</div>
    </div>
    <div id="direction-controls" class="touch-controls">
        <div class="touch-button" id="pitch-up">↑</div>
        <div class="touch-button" id="turn-left">←</div>
        <div class="touch-button" id="turn-right">→</div>
        <div class="touch-button" id="pitch-down">↓</div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Initialize Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create airplane (Cessna-style)
        const airplane = new THREE.Group();
        
        // Fuselage
        const fuselage = new THREE.Mesh(
            new THREE.CylinderGeometry(0.4, 0.4, 4, 12),
            new THREE.MeshPhongMaterial({ 
                color: 0xFFFFFF,  // White color
                shininess: 100
            })
        );
        fuselage.rotation.x = -Math.PI / 2;  // Changed rotation direction

        // Main wings (high-wing configuration)
        const mainWing = new THREE.Mesh(
            new THREE.BoxGeometry(8, 0.1, 1.5),
            new THREE.MeshPhongMaterial({ 
                color: 0xFFFFFF,
                shininess: 100
            })
        );
        mainWing.position.set(0, 0.4, 0);

        // Wing struts (supports)
        const strutLeft = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.8, 1),
            new THREE.MeshPhongMaterial({ color: 0x888888 })
        );
        strutLeft.position.set(-2, -0.1, 0);
        
        const strutRight = strutLeft.clone();
        strutRight.position.set(2, -0.1, 0);

        // Tail section
        const tailFin = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 1.2, 1.2),
            new THREE.MeshPhongMaterial({ color: 0xFFFFFF })
        );
        tailFin.position.set(0, 0.6, 2);  // Changed from -2 to 2

        const tailWing = new THREE.Mesh(
            new THREE.BoxGeometry(2.5, 0.1, 0.8),
            new THREE.MeshPhongMaterial({ color: 0xFFFFFF })
        );
        tailWing.position.set(0, 0.3, 2);  // Changed from -2 to 2

        // Nose with propeller
        const nose = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.4, 0.5, 12),
            new THREE.MeshPhongMaterial({ color: 0x333333 })
        );
        nose.rotation.x = -Math.PI / 2;  // Changed rotation direction
        nose.position.z = -2.2;  // Changed from 2.2 to -2.2

        const propeller = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 1.6, 0.2),
            new THREE.MeshPhongMaterial({ color: 0x333333 })
        );
        propeller.position.z = -2.5;  // Changed from 2.5 to -2.5

        // Create landing gear struts
        const strutGeometry = new THREE.BoxGeometry(0.1, 0.8, 0.1);
        const strutMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });

        // Front landing gear
        const leftGearGroup = new THREE.Group();  // Create groups for each gear
        const leftGearStrut = new THREE.Mesh(strutGeometry, strutMaterial);
        leftGearStrut.position.set(0, -0.4, 0);
        leftGearGroup.add(leftGearStrut);
        leftGearGroup.position.set(-1, 0, -0.5);  // Position the group relative to plane
        
        const rightGearGroup = new THREE.Group();
        const rightGearStrut = new THREE.Mesh(strutGeometry, strutMaterial);
        rightGearStrut.position.set(0, -0.4, 0);
        rightGearGroup.add(rightGearStrut);
        rightGearGroup.position.set(1, 0, -0.5);

        const tailGearGroup = new THREE.Group();
        const tailGearStrut = new THREE.Mesh(strutGeometry, strutMaterial);
        tailGearStrut.scale.set(0.6, 0.6, 0.6);
        tailGearStrut.position.set(0, -0.2, 0);
        tailGearGroup.add(tailGearStrut);
        tailGearGroup.position.set(0, 0, 1.8);

        // Create wheels
        const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 8);
        wheelGeometry.rotateZ(Math.PI / 2);
        const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });

        const leftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        leftWheel.position.set(0, -0.8, 0);
        leftGearStrut.add(leftWheel);

        const rightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        rightWheel.position.set(0, -0.8, 0);
        rightGearStrut.add(rightWheel);

        const tailWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        tailWheel.scale.set(0.6, 0.6, 0.6);
        tailWheel.position.set(0, -0.5, 0);
        tailGearStrut.add(tailWheel);

        // Add gear to airplane
        airplane.add(leftGearGroup);
        airplane.add(rightGearGroup);
        airplane.add(tailGearGroup);

        // Windows
        const cockpitGlass = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 0.5, 1.2),
            new THREE.MeshPhongMaterial({
                color: 0x88CCFF,
                transparent: true,
                opacity: 0.5,
                shininess: 100
            })
        );
        cockpitGlass.position.set(0, 0.5, -0.5);  // Changed z from 0.5 to -0.5

        // Add all parts to airplane
        airplane.add(fuselage);
        airplane.add(mainWing);
        airplane.add(strutLeft);
        airplane.add(strutRight);
        airplane.add(tailFin);
        airplane.add(tailWing);
        airplane.add(nose);
        airplane.add(propeller);
        scene.add(airplane);

        // Create runway (larger and more visible)
        const runway = new THREE.Group();
        
        // Main runway strip
        const runwayStrip = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 200),
            new THREE.MeshPhongMaterial({ color: 0x444444 }) // Dark gray
        );
        runwayStrip.rotation.x = -Math.PI / 2;
        runway.add(runwayStrip);

        // Runway markings
        const markingMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
        for (let i = -90; i <= 90; i += 20) {
            const marking = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 10),
                markingMaterial
            );
            marking.rotation.x = -Math.PI / 2;
            marking.position.z = i;
            marking.position.y = 0.01; // Slightly above runway to prevent z-fighting
            runway.add(marking);
        }
        
        runway.position.z = 20;
        scene.add(runway);

        // Create flat ground
        const groundGeometry = new THREE.PlaneGeometry(4000, 4000);
        const ground = new THREE.Mesh(
            groundGeometry,
            new THREE.MeshPhongMaterial({ 
                color: 0x228B22,
                flatShading: true 
            })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.1;
        scene.add(ground);

        // Create skybox with larger size
        const skyboxGeometry = new THREE.BoxGeometry(4000, 4000, 4000);
        const skyboxMaterials = [
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0x87CEEB), // Light blue
                side: THREE.BackSide 
            }),
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0x87CEEB),
                side: THREE.BackSide 
            }),
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0x4169E1), // Royal blue for top
                side: THREE.BackSide 
            }),
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0xADD8E6), // Light blue for bottom
                side: THREE.BackSide 
            }),
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0x87CEEB),
                side: THREE.BackSide 
            }),
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0x87CEEB),
                side: THREE.BackSide 
            })
        ];
        
        const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
        scene.add(skybox);

        // Create clouds
        function createCloud() {
            const cloudGeometry = new THREE.SphereGeometry(15, 8, 8);
            const cloudMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                flatShading: true
            });

            const cloud = new THREE.Group();
            
            // Create random blob-like cloud shape
            for (let i = 0; i < 5 + Math.random() * 5; i++) {
                const blob = new THREE.Mesh(cloudGeometry, cloudMaterial);
                blob.position.set(
                    Math.random() * 20 - 10,
                    Math.random() * 10 - 5,
                    Math.random() * 20 - 10
                );
                blob.scale.set(
                    0.5 + Math.random() * 0.5,
                    0.5 + Math.random() * 0.3,
                    0.5 + Math.random() * 0.5
                );
                cloud.add(blob);
            }
            
            return cloud;
        }

        // Add clouds to scene
        const clouds = new THREE.Group();
        const cloudCount = 50;
        const cloudArea = 2000;  // Area where clouds can spawn
        const minCloudHeight = 200;
        const maxCloudHeight = 400;

        for (let i = 0; i < cloudCount; i++) {
            const cloud = createCloud();
            cloud.position.set(
                (Math.random() - 0.5) * cloudArea,
                minCloudHeight + Math.random() * (maxCloudHeight - minCloudHeight),
                (Math.random() - 0.5) * cloudArea
            );
            cloud.rotation.y = Math.random() * Math.PI * 2;
            clouds.add(cloud);
        }
        scene.add(clouds);

        // Fix building creation function
        function createBuilding(x, z, height) {
            const building = new THREE.Group();
            
            // Main building body
            const bodyGeometry = new THREE.BoxGeometry(
                10 + Math.random() * 10,
                height,
                10 + Math.random() * 10
            );
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color(
                    0.5 + Math.random() * 0.2,
                    0.5 + Math.random() * 0.2,
                    0.5 + Math.random() * 0.2
                )
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            
            // Windows
            const windowMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                emissive: 0x555555
            });
            
            for (let i = 1; i < height; i += 4) {
                for (let j = -1; j <= 1; j += 1) {
                    const window = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 2, 2),
                        windowMaterial
                    );
                    window.position.set(
                        bodyGeometry.parameters.width/2,
                        i - height/2,
                        j * 3
                    );
                    body.add(window);
                    
                    const window2 = window.clone();
                    window2.position.x = -bodyGeometry.parameters.width/2;
                    body.add(window2);
                }
            }
            
            building.add(body);
            building.position.set(x, height/2, z);  // Removed groundHeight
            return building;
        }

        // Add buildings to scene
        const cityArea = 1600;  // Doubled city area
        const buildingCount = 100;  // More buildings
        const minHeight = 30;
        const maxHeight = 150;
        
        let buildings = [];  // Array to track buildings
        
        for (let i = 0; i < buildingCount; i++) {
            const x = (Math.random() - 0.5) * cityArea;
            const z = (Math.random() - 0.5) * cityArea;
            
            if (Math.abs(x) > 50 || Math.abs(z) > 100) {
                const height = minHeight + Math.random() * (maxHeight - minHeight);
                const building = createBuilding(x, z, height);
                scene.add(building);
                buildings.push(building);  // Add to tracking array
            }
        }

        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Camera position
        camera.position.set(0, 2, -5);
        camera.lookAt(airplane.position);

        // Physics variables
        let speed = 0;
        let altitude = 0;
        let pitch = 0;
        let roll = 0;
        let yaw = 0;
        let throttle = 0;
        let isAirborne = false;
        let takeoffMessageTimer = null;  // Add timer variable
        
        // Aircraft characteristics - simplified arcade style
        const maxGroundSpeed = 150;    // Max speed on ground
        const maxAirSpeed = 200;       // Max speed in air
        const takeoffSpeed = 60;       // Speed needed for takeoff
        const acceleration = 0.8;      // Ground acceleration
        const deceleration = 0.3;      // Ground deceleration
        const pitchRate = 0.015;       // Reduced pitch rate
        const rollRate = 0.02;         // Roll control sensitivity
        const turnRate = 0.02;         // Turn rate
        const gravity = 0.1;           // Reduced gravity
        const liftRate = 0.05;         // Reduced lift rate significantly

        // Controls
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        // Touch controls setup
        function setupTouchControls() {
            // Helper function for both touch and click events
            function setupButton(elementId, key) {
                const element = document.getElementById(elementId);
                if (!element) return;

                function pressButton(e) {
                    e.preventDefault();
                    keys[key] = true;
                    element.style.background = 'rgba(255,255,255,0.6)';
                    element.style.transform = 'scale(0.95)';
                }

                function releaseButton(e) {
                    e.preventDefault();
                    keys[key] = false;
                    element.style.background = 'rgba(255,255,255,0.4)';
                    element.style.transform = 'scale(1)';
                }

                // Touch events
                element.addEventListener('touchstart', pressButton, { passive: false });
                element.addEventListener('touchend', releaseButton, { passive: false });
                element.addEventListener('touchcancel', releaseButton, { passive: false });

                // Mouse events
                element.addEventListener('mousedown', pressButton);
                element.addEventListener('mouseup', releaseButton);
                element.addEventListener('mouseleave', releaseButton);

                // Prevent text selection
                element.addEventListener('selectstart', (e) => e.preventDefault());
            }

            // Setup each control
            const controls = [
                ['throttle-up', 'w'],
                ['throttle-down', 's'],
                ['pitch-up', 'ArrowUp'],
                ['pitch-down', 'ArrowDown'],
                ['turn-left', 'ArrowLeft'],
                ['turn-right', 'ArrowRight']
            ];

            controls.forEach(([elementId, key]) => {
                setupButton(elementId, key);
            });

            // Prevent page scrolling when touching the game area
            document.addEventListener('touchmove', (e) => {
                if (e.target.closest('.touch-controls')) {
                    e.preventDefault();
                }
            }, { passive: false });

            // Prevent context menu on long press
            document.addEventListener('contextmenu', (e) => {
                if (e.target.closest('.touch-controls')) {
                    e.preventDefault();
                }
            });

            // Add shoot button control
            const shootButton = document.getElementById('shoot-button');
            if (shootButton) {
                function pressShootButton(e) {
                    e.preventDefault();
                    shoot();
                    shootButton.style.background = 'rgba(255, 100, 100, 0.6)';
                    shootButton.style.transform = 'scale(0.95)';
                }

                function releaseShootButton(e) {
                    e.preventDefault();
                    shootButton.style.background = 'rgba(255, 100, 100, 0.4)';
                    shootButton.style.transform = 'scale(1)';
                }

                shootButton.addEventListener('touchstart', pressShootButton, { passive: false });
                shootButton.addEventListener('touchend', releaseShootButton, { passive: false });
                shootButton.addEventListener('mousedown', pressShootButton);
                shootButton.addEventListener('mouseup', releaseShootButton);
                shootButton.addEventListener('mouseleave', releaseShootButton);
            }
        }

        setupTouchControls();

        // Update camera far plane to see further
        camera.far = 3000;
        camera.updateProjectionMatrix();

        // After the bullet variables, add:
        const bullets = [];
        const explosions = [];  // Add this line
        const bulletSpeed = 3;
        const bulletLifetime = 1000;
        const shootingCooldown = 100;
        let lastShootTime = 0;

        // After the bullet variables, add sound setup
        const audioListener = new THREE.AudioListener();
        camera.add(audioListener);

        // Load explosion sound
        const explosionSound = new Audio('https://assets.mixkit.co/active_storage/sfx/2285/2285-preview.mp3');
        explosionSound.volume = 0.4;

        // After the audio setup, add bullet geometry and material
        const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
        const bulletMaterial = new THREE.MeshPhongMaterial({
            color: 0xffff00,
            emissive: 0xff8800
        });

        // Increase detection radius for more reliable hits
        const explosionRadius = 50;  // Much bigger radius
        const planeCollisionRadius = 20;  // Bigger plane collision radius

        // Simplified explosion variables
        const explosionDuration = 500;  // Shorter duration
        const explosionParticleCount = 8;  // Much fewer particles
        const explosionForce = 4;

        // Simpler particle geometry
        const particleGeometry = new THREE.BoxGeometry(1, 1, 1);
        const particleMaterial = new THREE.MeshPhongMaterial({
            color: 0xff4400,
            emissive: 0xff2200
        });

        // Replace explosion sound with synth bass
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playExplosionSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(30, audioContext.currentTime + 0.2);
            
            gainNode.gain.setValueAtTime(1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.2);
        }

        // Simplified explosion function
        function createExplosion(position) {
            playExplosionSound();
            
            const explosion = new THREE.Group();
            explosion.position.copy(position);
            explosion.createdAt = Date.now();
            
            // Fewer particles with simpler movement
            for (let i = 0; i < explosionParticleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Simpler velocity calculation
                particle.velocity = {
                    x: (Math.random() - 0.5) * explosionForce,
                    y: Math.random() * explosionForce,
                    z: (Math.random() - 0.5) * explosionForce
                };
                
                explosion.add(particle);
            }
            
            scene.add(explosion);
            explosions.push(explosion);

            // Auto-remove explosion after duration
            setTimeout(() => {
                scene.remove(explosion);
                const index = explosions.indexOf(explosion);
                if (index > -1) {
                    explosions.splice(index, 1);
                }
            }, explosionDuration);
        }

        // Optimize collision detection
        const collisionCheckInterval = 100; // Check every 100ms
        let lastCollisionCheck = 0;

        // Fix propeller rotation variables
        const propellerSpeed = 0.2;  // Reduced base speed
        const minPropellerSpeed = 0.1;  // Minimum speed when idle
        const maxPropellerSpeed = 0.8;  // Maximum speed at full throttle
        let propellerRotation = 0;

        // Create birds with larger size
        function createBird() {
            const bird = new THREE.Group();
            
            // Bird body - bigger and more visible
            const body = new THREE.Mesh(
                new THREE.ConeGeometry(2, 8, 4),  // Much bigger body
                new THREE.MeshPhongMaterial({ 
                    color: 0x222222,  // Darker color
                    shininess: 30 
                })
            );
            body.rotation.x = Math.PI / 2;
            bird.add(body);
            
            // Wings - larger wingspan
            const wingGeometry = new THREE.BoxGeometry(16, 0.3, 4);  // Much wider wings
            const wingMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x222222,
                shininess: 30
            });
            
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            wings.position.y = 1;  // Raised slightly
            bird.add(wings);
            
            // Add animation properties
            bird.wingAngle = 0;
            bird.speed = 1 + Math.random();  // Faster speed
            bird.turnRate = (Math.random() - 0.5) * 0.02;
            bird.yaw = Math.random() * Math.PI * 2;
            
            return bird;
        }

        // Adjust bird placement
        const birds = new THREE.Group();
        const birdCount = 30;  // Fewer birds but bigger
        const birdArea = 1000;
        const minBirdHeight = 150;  // Higher minimum height
        const maxBirdHeight = 400;  // Higher maximum height

        for (let i = 0; i < birdCount; i++) {
            const bird = createBird();
            bird.position.set(
                (Math.random() - 0.5) * birdArea,
                minBirdHeight + Math.random() * (maxBirdHeight - minBirdHeight),
                (Math.random() - 0.5) * birdArea
            );
            birds.add(bird);
        }
        scene.add(birds);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Handle throttle
            if (keys['w'] || keys['W']) {
                throttle = Math.min(throttle + 0.02, 1);
            } else if (keys['s'] || keys['S']) {
                throttle = Math.max(throttle - 0.02, 0);
            }

            // Handle pitch
            if (keys['ArrowDown']) {  // Pull back (nose up)
                if (isAirborne || speed >= takeoffSpeed * 0.8) {
                    pitch = Math.min(pitch + pitchRate, Math.PI / 4);
                }
            } else if (keys['ArrowUp']) {  // Push forward (nose down)
                if (isAirborne) {
                    pitch = Math.max(pitch - pitchRate, -Math.PI / 4);
                }
            } else {
                pitch *= 0.95;  // Return to level
            }

            // Handle turning
            if (keys['ArrowLeft']) {
                if (isAirborne) {
                    roll = Math.min(roll + rollRate, Math.PI / 3);
                }
                yaw += turnRate * (isAirborne ? Math.abs(roll) * 0.5 : 1);
            } else if (keys['ArrowRight']) {
                if (isAirborne) {
                    roll = Math.max(roll - rollRate, -Math.PI / 3);
                }
                yaw -= turnRate * (isAirborne ? Math.abs(roll) * 0.5 : 1);
            } else {
                roll *= 0.95;  // Return to level
            }

            // Update speed
            if (!isAirborne) {
                // Ground movement
                if (throttle > 0) {
                    speed += throttle * acceleration;
                } else {
                    speed = Math.max(0, speed - deceleration);
                }
                speed = Math.min(speed, maxGroundSpeed);
            } else {
                // Air movement
                speed = Math.max(0, Math.min(maxAirSpeed, speed + (throttle - 0.5) * acceleration));
            }

            // Check for takeoff
            if (!isAirborne && speed >= takeoffSpeed && pitch > 0.1) {
                isAirborne = true;
                if (takeoffMessage) {
                    takeoffMessage.style.display = 'block';
                    if (takeoffMessageTimer) clearTimeout(takeoffMessageTimer);
                    takeoffMessageTimer = setTimeout(() => {
                        takeoffMessage.style.display = 'none';
                    }, 2000);
                }
            }

            // Update altitude with more gradual changes
            if (isAirborne) {
                // More gradual altitude changes
                const liftForce = (pitch * speed * liftRate);
                const verticalSpeed = liftForce - gravity;
                altitude += verticalSpeed;
                
                // Prevent sudden drops
                if (altitude <= 0) {
                    altitude = 0;
                    isAirborne = false;
                    speed *= 0.8;  // Reduce speed on landing
                }
            } else {
                altitude = 0;
            }

            // Update airplane position and rotation
            airplane.position.y = altitude;
            airplane.rotation.x = pitch;
            airplane.rotation.z = roll;
            airplane.rotation.y = yaw;

            const movement = speed * 0.01;
            airplane.position.x -= Math.sin(yaw) * movement;
            airplane.position.z -= Math.cos(yaw) * movement;

            // Update camera to follow from behind
            const cameraDistance = 5;
            camera.position.x = airplane.position.x + Math.sin(yaw) * cameraDistance;  // Changed minus to plus
            camera.position.z = airplane.position.z + Math.cos(yaw) * cameraDistance;  // Changed minus to plus
            camera.position.y = airplane.position.y + 2;
            camera.lookAt(airplane.position);

            // Update skybox position to follow camera
            skybox.position.copy(camera.position);

            // Move clouds slowly
            clouds.children.forEach((cloud, index) => {
                cloud.position.x += Math.sin(Date.now() * 0.0001 + index) * 0.1;
                cloud.position.z += Math.cos(Date.now() * 0.0001 + index) * 0.1;
                
                // Wrap clouds around when they go too far
                const halfCloudArea = cloudArea / 2;
                if (cloud.position.x > halfCloudArea) cloud.position.x = -halfCloudArea;
                if (cloud.position.x < -halfCloudArea) cloud.position.x = halfCloudArea;
                if (cloud.position.z > halfCloudArea) cloud.position.z = -halfCloudArea;
                if (cloud.position.z < -halfCloudArea) cloud.position.z = halfCloudArea;
                
                // Slowly rotate clouds
                cloud.rotation.y += 0.001;
            });

            // Update bullets and check collisions
            const now = Date.now();
            if (now - lastCollisionCheck > collisionCheckInterval) {
                lastCollisionCheck = now;
                
                // Check building collisions less frequently
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    for (let j = buildings.length - 1; j >= 0; j--) {
                        const building = buildings[j];
                        const distance = bullet.position.distanceTo(building.position);
                        if (distance < explosionRadius) {
                            createExplosion(building.position);
                            scene.remove(building);
                            buildings.splice(j, 1);
                            scene.remove(bullet);
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                }
            }

            // Update bullet positions
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.position.x += bullet.velocity.x;
                bullet.position.y += bullet.velocity.y;
                bullet.position.z += bullet.velocity.z;

                // Remove old bullets
                if (now - bullet.createdAt > bulletLifetime) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }

            // Update propeller rotation - more realistic speed
            if (!isAirborne) {
                // Slower on ground
                propellerRotation += (throttle * propellerSpeed + minPropellerSpeed);
            } else {
                // Faster in air, based on speed
                propellerRotation += Math.min(
                    maxPropellerSpeed,
                    (throttle * propellerSpeed + minPropellerSpeed) * (1 + speed/100)
                );
            }
            propeller.rotation.z = propellerRotation;

            // Update birds
            birds.children.forEach((bird, index) => {
                // Flap wings
                bird.wingAngle += 0.2;
                bird.children[1].rotation.z = Math.sin(bird.wingAngle) * 0.3;
                
                // Move bird
                bird.yaw += bird.turnRate;
                bird.position.x += Math.sin(bird.yaw) * bird.speed;
                bird.position.z += Math.cos(bird.yaw) * bird.speed;
                bird.rotation.y = bird.yaw;
                
                // Wrap birds around when they go too far
                const halfBirdArea = birdArea / 2;
                if (bird.position.x > halfBirdArea) bird.position.x = -halfBirdArea;
                if (bird.position.x < -halfBirdArea) bird.position.x = halfBirdArea;
                if (bird.position.z > halfBirdArea) bird.position.z = -halfBirdArea;
                if (bird.position.z < -halfBirdArea) bird.position.z = halfBirdArea;
            });

            // Update HUD
            document.getElementById('speed').textContent = Math.round(speed);
            document.getElementById('altitude').textContent = Math.round(altitude);

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

        // Add shooting function
        function shoot() {
            const now = Date.now();
            if (now - lastShootTime < shootingCooldown) return;
            lastShootTime = now;

            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.position.copy(airplane.position);
            bullet.rotation.copy(airplane.rotation);
            bullet.createdAt = now;
            
            // Fix bullet velocity to shoot forward from plane's direction
            bullet.velocity = {
                x: -Math.sin(yaw) * bulletSpeed,  // Add back negative sign
                y: Math.sin(pitch) * bulletSpeed,
                z: -Math.cos(yaw) * bulletSpeed   // Add back negative sign
            };
            
            scene.add(bullet);
            bullets.push(bullet);
        }

        // Make sure Space key handler is properly set up
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.code === 'Space' || e.key === ' ') {  // Handle both Space and spacebar
                shoot();
            }
        });
    </script>
</body>
</html> 