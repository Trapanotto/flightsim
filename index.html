<!DOCTYPE html>
<html>
<head>
    <title>Trapanotto Flight Simulator</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            line-height: 1.4;
        }
        .touch-controls {
            position: fixed;
            pointer-events: none;
        }
        .touch-button {
            width: 80px;
            height: 80px;
            background: rgba(255,255,255,0.4);
            border: 2px solid white;
            border-radius: 50%;
            color: white;
            font-size: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            pointer-events: auto;
            cursor: pointer;
            touch-action: none;
        }
        #throttle-controls {
            position: fixed;
            right: 40px;
            bottom: 40px;
        }
        #direction-controls {
            position: fixed;
            left: 40px;
            bottom: 40px;
        }
        /* Specific button positions for direction controls */
        #pitch-up {
            position: absolute;
            bottom: 160px;
            left: 80px;
        }
        
        #turn-left {
            position: absolute;
            bottom: 80px;
            left: 0;
        }
        
        #turn-right {
            position: absolute;
            bottom: 80px;
            left: 160px;
        }
        
        #pitch-down {
            position: absolute;
            bottom: 0;
            left: 80px;
        }
        
        /* Specific button positions for throttle controls */
        #throttle-up {
            position: absolute;
            bottom: 120px;
            right: 40px;
        }
        
        #throttle-down {
            position: absolute;
            bottom: 20px;
            right: 40px;
        }
        @media (max-width: 768px) {
            .touch-button {
                width: 65px;
                height: 65px;
                font-size: 26px;
            }
            /* Adjust positions for smaller screens */
            #pitch-up { 
                bottom: 130px;
                left: 65px;
            }
            #turn-left {
                bottom: 65px;
                left: 0;
            }
            #turn-right {
                bottom: 65px;
                left: 130px;
            }
            #pitch-down {
                bottom: 0;
                left: 65px;
            }
            #throttle-up {
                bottom: 100px;
                right: 30px;
            }
            #throttle-down {
                bottom: 15px;
                right: 30px;
            }
        }
        @media (max-width: 480px) {
            .touch-button {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            /* Adjust positions for mobile screens */
            #pitch-up {
                bottom: 100px;
                left: 50px;
            }
            #turn-left {
                bottom: 50px;
                left: 0;
            }
            #turn-right {
                bottom: 50px;
                left: 100px;
            }
            #pitch-down {
                bottom: 0;
                left: 50px;
            }
            #throttle-up {
                bottom: 80px;
                right: 20px;
            }
            #throttle-down {
                bottom: 10px;
                right: 20px;
            }
        }
        #shoot-button {
            position: fixed;
            right: 40px;
            top: 40px;
            width: 100px;
            height: 100px;
            background: rgba(255, 100, 100, 0.4);
            border: 2px solid #ff6666;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            cursor: pointer;
            touch-action: none;
        }
        @media (max-width: 768px) {
            #shoot-button {
                width: 80px;
                height: 80px;
                font-size: 20px;
                right: 30px;
                top: 30px;
            }
        }
        @media (max-width: 480px) {
            #shoot-button {
                width: 60px;
                height: 60px;
                font-size: 16px;
                right: 20px;
                top: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="hud">
        Speed: <span id="speed">0</span> km/h<br>
        Altitude: <span id="altitude">0</span> m<br>
        FPS: <span id="fps">0</span><br>
        <br>
        Controls:<br>
        W/S - Throttle Up/Down<br>
        ↑/↓ - Pitch (pull back/DOWN to take off)<br>
        ←/→ - Turn Left/Right (Roll when airborne)<br>
        SPACE - Fire Weapons<br>
        <div id="takeoff-message" style="display: none; color: #ff0; font-size: 1.2em; margin-top: 10px; font-weight: bold;">TAKEOFF</div>
    </div>
    <div id="shoot-button" class="touch-button">FIRE</div>
    <div id="throttle-controls" class="touch-controls">
        <div class="touch-button" id="throttle-up">W</div>
        <div class="touch-button" id="throttle-down">S</div>
    </div>
    <div id="direction-controls" class="touch-controls">
        <div class="touch-button" id="pitch-up">↑</div>
        <div class="touch-button" id="turn-left">←</div>
        <div class="touch-button" id="turn-right">→</div>
        <div class="touch-button" id="pitch-down">↓</div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Initialize Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Enable shadows in the renderer
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowMap.autoUpdate = true;
        renderer.shadowMap.needsUpdate = true;

        // Create airplane (Cessna-style)
        const airplane = new THREE.Group();
        
        // Fuselage
        const fuselage = new THREE.Mesh(
            new THREE.CylinderGeometry(0.4, 0.4, 4, 12),
            new THREE.MeshPhongMaterial({ 
                color: 0xFFFFFF,  // White color
                shininess: 100
            })
        );
        fuselage.rotation.x = -Math.PI / 2;  // Changed rotation direction

        // Main wings (high-wing configuration)
        const mainWing = new THREE.Mesh(
            new THREE.BoxGeometry(8, 0.1, 1.5),
            new THREE.MeshPhongMaterial({ 
                color: 0xFFFFFF,
                shininess: 100
            })
        );
        mainWing.position.set(0, 0.4, 0);

        // Wing struts (supports)
        const strutLeft = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.8, 1),
            new THREE.MeshPhongMaterial({ color: 0x888888 })
        );
        strutLeft.position.set(-2, -0.1, 0);
        
        const strutRight = strutLeft.clone();
        strutRight.position.set(2, -0.1, 0);

        // Tail section
        const tailFin = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 1.2, 1.2),
            new THREE.MeshPhongMaterial({ color: 0xFFFFFF })
        );
        tailFin.position.set(0, 0.6, 2);  // Changed from -2 to 2

        const tailWing = new THREE.Mesh(
            new THREE.BoxGeometry(2.5, 0.1, 0.8),
            new THREE.MeshPhongMaterial({ color: 0xFFFFFF })
        );
        tailWing.position.set(0, 0.3, 2);  // Changed from -2 to 2

        // Nose with propeller
        const nose = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.4, 0.5, 12),
            new THREE.MeshPhongMaterial({ color: 0x333333 })
        );
        nose.rotation.x = -Math.PI / 2;  // Changed rotation direction
        nose.position.z = -2.2;  // Changed from 2.2 to -2.2

        const propeller = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 1.6, 0.2),
            new THREE.MeshPhongMaterial({ color: 0x333333 })
        );
        propeller.position.z = -2.5;  // Changed from 2.5 to -2.5

        // Create landing gear struts
        const strutGeometry = new THREE.BoxGeometry(0.1, 0.8, 0.1);
        const strutMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });

        // Front landing gear
        const leftGearGroup = new THREE.Group();  // Create groups for each gear
        const leftGearStrut = new THREE.Mesh(strutGeometry, strutMaterial);
        leftGearStrut.position.set(0, -0.4, 0);
        leftGearGroup.add(leftGearStrut);
        leftGearGroup.position.set(-1, 0, -0.5);  // Position the group relative to plane
        
        const rightGearGroup = new THREE.Group();
        const rightGearStrut = new THREE.Mesh(strutGeometry, strutMaterial);
        rightGearStrut.position.set(0, -0.4, 0);
        rightGearGroup.add(rightGearStrut);
        rightGearGroup.position.set(1, 0, -0.5);

        const tailGearGroup = new THREE.Group();
        const tailGearStrut = new THREE.Mesh(strutGeometry, strutMaterial);
        tailGearStrut.scale.set(0.6, 0.6, 0.6);
        tailGearStrut.position.set(0, -0.2, 0);
        tailGearGroup.add(tailGearStrut);
        tailGearGroup.position.set(0, 0, 1.8);

        // Create wheels
        const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 8);
        wheelGeometry.rotateZ(Math.PI / 2);
        const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });

        const leftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        leftWheel.position.set(0, -0.8, 0);
        leftGearStrut.add(leftWheel);

        const rightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        rightWheel.position.set(0, -0.8, 0);
        rightGearStrut.add(rightWheel);

        const tailWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        tailWheel.scale.set(0.6, 0.6, 0.6);
        tailWheel.position.set(0, -0.5, 0);
        tailGearStrut.add(tailWheel);

        // Add gear to airplane
        airplane.add(leftGearGroup);
        airplane.add(rightGearGroup);
        airplane.add(tailGearGroup);

        // Windows
        const cockpitGlass = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 0.5, 1.2),
            new THREE.MeshPhongMaterial({
                color: 0x88CCFF,
                transparent: true,
                opacity: 0.5,
                shininess: 100
            })
        );
        cockpitGlass.position.set(0, 0.5, -0.5);  // Changed z from 0.5 to -0.5

        // Add all parts to airplane
        airplane.add(fuselage);
        airplane.add(mainWing);
        airplane.add(strutLeft);
        airplane.add(strutRight);
        airplane.add(tailFin);
        airplane.add(tailWing);
        airplane.add(nose);
        airplane.add(propeller);
        scene.add(airplane);

        // Create runway (larger and more visible)
        const runway = new THREE.Group();
        
        // Main runway strip
        const runwayStrip = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 200),
            new THREE.MeshPhongMaterial({ color: 0x444444 }) // Dark gray
        );
        runwayStrip.rotation.x = -Math.PI / 2;
        runway.add(runwayStrip);

        // Runway markings
        const markingMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
        for (let i = -90; i <= 90; i += 20) {
            const marking = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 10),
                markingMaterial
            );
            marking.rotation.x = -Math.PI / 2;
            marking.position.z = i;
            marking.position.y = 0.01; // Slightly above runway to prevent z-fighting
            runway.add(marking);
        }
        
        runway.position.z = 20;
        scene.add(runway);

        // Create simple flat ground
        const groundSize = 4000;  // Large single ground piece
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
        const groundMaterial = new THREE.MeshPhongMaterial({
            color: 0x228B22,  // Forest green
            shininess: 0,
            side: THREE.DoubleSide
        });
        
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;  // Lay flat
        ground.position.y = -0.1;  // Slightly below zero
        ground.receiveShadow = true;
        scene.add(ground);

        // Create skybox with larger size
        const skyboxGeometry = new THREE.BoxGeometry(4000, 4000, 4000);
        const skyboxMaterials = [
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0x87CEEB), // Light blue
                side: THREE.BackSide 
            }),
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0x87CEEB),
                side: THREE.BackSide 
            }),
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0x4169E1), // Royal blue for top
                side: THREE.BackSide 
            }),
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0xADD8E6), // Light blue for bottom
                side: THREE.BackSide 
            }),
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0x87CEEB),
                side: THREE.BackSide 
            }),
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0x87CEEB),
                side: THREE.BackSide 
            })
        ];
        
        const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
        scene.add(skybox);

        // Create clouds
        function createCloud() {
            const cloudGeometry = new THREE.SphereGeometry(15, 8, 8);
            const cloudMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                flatShading: true
            });

            const cloud = new THREE.Group();
            
            // Create random blob-like cloud shape
            for (let i = 0; i < 5 + Math.random() * 5; i++) {
                const blob = new THREE.Mesh(cloudGeometry, cloudMaterial);
                blob.position.set(
                    Math.random() * 20 - 10,
                    Math.random() * 10 - 5,
                    Math.random() * 20 - 10
                );
                blob.scale.set(
                    0.5 + Math.random() * 0.5,
                    0.5 + Math.random() * 0.3,
                    0.5 + Math.random() * 0.5
                );
                cloud.add(blob);
            }
            
            return cloud;
        }

        // Add clouds to scene
        const clouds = new THREE.Group();
        const cloudCount = 50;
        const cloudArea = 2000;  // Area where clouds can spawn
        const minCloudHeight = 200;
        const maxCloudHeight = 400;

        for (let i = 0; i < cloudCount; i++) {
            const cloud = createCloud();
            cloud.position.set(
                (Math.random() - 0.5) * cloudArea,
                minCloudHeight + Math.random() * (maxCloudHeight - minCloudHeight),
                (Math.random() - 0.5) * cloudArea
            );
            cloud.rotation.y = Math.random() * Math.PI * 2;
            clouds.add(cloud);
        }
        scene.add(clouds);

        // Add lights first (move this up, before the sun creation)
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1000, 800, -1000);  // Match sun position
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 8192;  // Increased resolution
        directionalLight.shadow.mapSize.height = 8192;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 5000;  // Increased far plane
        directionalLight.shadow.camera.left = -1000;  // Wider view
        directionalLight.shadow.camera.right = 1000;
        directionalLight.shadow.camera.top = 1000;
        directionalLight.shadow.camera.bottom = -1000;
        directionalLight.shadow.bias = -0.0001;  // Adjusted bias
        directionalLight.shadow.normalBias = 0.02;  // Added normal bias
        directionalLight.shadow.radius = 1.5;  // Softer shadows
        scene.add(directionalLight);

        // Create sun with happy face
        const sunGeometry = new THREE.SphereGeometry(50, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({
            color: 0xffff00,
            emissive: 0xffaa00,
            emissiveIntensity: 1,
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.position.copy(directionalLight.position);

        // Add sun face features
        const eyeGeometry = new THREE.SphereGeometry(5, 16, 16);
        const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        
        // Left eye
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-15, 15, 40);
        sun.add(leftEye);
        
        // Right eye
        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(15, 15, 40);
        sun.add(rightEye);
        
        // Happy mouth (curved line)
        const mouthGeometry = new THREE.TorusGeometry(20, 3, 16, 32, Math.PI);
        const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
        mouth.position.set(0, -5, 40);
        mouth.rotation.x = Math.PI / 2;
        sun.add(mouth);

        scene.add(sun);

        // Update building creation to enhance shadows
        function createBuilding(x, z, height) {
            const building = new THREE.Group();
            
            const bodyGeometry = new THREE.BoxGeometry(
                10 + Math.random() * 10,
                height,
                10 + Math.random() * 10
            );
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color(
                    0.5 + Math.random() * 0.2,
                    0.5 + Math.random() * 0.2,
                    0.5 + Math.random() * 0.2
                ),
                shininess: 30,
                shadowSide: THREE.BackSide  // Added shadow side
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            
            // Enhanced shadow settings
            body.castShadow = true;
            body.receiveShadow = true;
            body.matrixAutoUpdate = true;
            body.updateMatrix();
            
            // Add windows that also cast shadows
            const windowMaterial = new THREE.MeshPhongMaterial({
                color: 0x88CCFF,
                emissive: 0x112233,
                shininess: 100
            });

            // Add windows on all sides
            const sides = [
                { x: 1, z: 0, rot: 0 },
                { x: -1, z: 0, rot: Math.PI },
                { x: 0, z: 1, rot: Math.PI/2 },
                { x: 0, z: -1, rot: -Math.PI/2 }
            ];

            sides.forEach(side => {
                for (let y = height * 0.1; y < height * 0.9; y += height * 0.15) {
                    const window = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 3, 0.5),
                        windowMaterial
                    );
                    window.position.set(
                        side.x * bodyGeometry.parameters.width/2,
                        y - height/2,
                        side.z * bodyGeometry.parameters.depth/2
                    );
                    window.rotation.y = side.rot;
                    window.castShadow = true;
                    window.receiveShadow = true;
                    body.add(window);
                }
            });

            building.add(body);
            building.position.set(x, height/2, z);
            
            // Make sure all children cast and receive shadows
            building.traverse(object => {
                if (object.isMesh) {
                    object.castShadow = true;
                    object.receiveShadow = true;
                }
            });

            return building;
        }

        // Add buildings to scene
        const cityArea = 1600;  // Doubled city area
        const buildingCount = 100;  // More buildings
        const minHeight = 30;
        const maxHeight = 150;
        
        let buildings = [];  // Array to track buildings
        
        for (let i = 0; i < buildingCount; i++) {
            const x = (Math.random() - 0.5) * cityArea;
            const z = (Math.random() - 0.5) * cityArea;
            
            if (Math.abs(x) > 50 || Math.abs(z) > 100) {
                const height = minHeight + Math.random() * (maxHeight - minHeight);
                const building = createBuilding(x, z, height);
                scene.add(building);
                buildings.push(building);  // Add to tracking array
            }
        }

        // Make objects cast and receive shadows
        runway.children.forEach(child => {
            child.receiveShadow = true;
        });

        // Make airplane cast shadows
        airplane.traverse(object => {
            if (object.isMesh) {
                object.castShadow = true;
                object.receiveShadow = true;
            }
        });

        // Camera position
        camera.position.set(0, 2, -5);
        camera.lookAt(airplane.position);

        // Physics variables
        let speed = 0;
        let altitude = 0;
        let pitch = 0;
        let roll = 0;
        let yaw = 0;
        let throttle = 0;
        let isAirborne = false;
        let takeoffMessageTimer = null;  // Add timer variable
        
        // Aircraft characteristics - simplified arcade style
        const maxGroundSpeed = 150;    // Max speed on ground
        const maxAirSpeed = 200;       // Max speed in air
        const takeoffSpeed = 60;       // Speed needed for takeoff
        const acceleration = 0.8;      // Ground acceleration
        const deceleration = 0.3;      // Ground deceleration
        const pitchRate = 0.015;       // Reduced pitch rate
        const rollRate = 0.02;         // Roll control sensitivity
        const turnRate = 0.02;         // Turn rate
        const gravity = 0.1;           // Reduced gravity
        const liftRate = 0.05;         // Reduced lift rate significantly

        // Controls
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        // Touch controls setup
        function setupTouchControls() {
            // Helper function for both touch and click events
            function setupButton(elementId, key) {
                const element = document.getElementById(elementId);
                if (!element) return;

                function pressButton(e) {
                    e.preventDefault();
                    keys[key] = true;
                    element.style.background = 'rgba(255,255,255,0.6)';
                    element.style.transform = 'scale(0.95)';
                }

                function releaseButton(e) {
                    e.preventDefault();
                    keys[key] = false;
                    element.style.background = 'rgba(255,255,255,0.4)';
                    element.style.transform = 'scale(1)';
                }

                // Touch events
                element.addEventListener('touchstart', pressButton, { passive: false });
                element.addEventListener('touchend', releaseButton, { passive: false });
                element.addEventListener('touchcancel', releaseButton, { passive: false });

                // Mouse events
                element.addEventListener('mousedown', pressButton);
                element.addEventListener('mouseup', releaseButton);
                element.addEventListener('mouseleave', releaseButton);

                // Prevent text selection
                element.addEventListener('selectstart', (e) => e.preventDefault());
            }

            // Setup each control
            const controls = [
                ['throttle-up', 'w'],
                ['throttle-down', 's'],
                ['pitch-up', 'ArrowUp'],
                ['pitch-down', 'ArrowDown'],
                ['turn-left', 'ArrowLeft'],
                ['turn-right', 'ArrowRight']
            ];

            controls.forEach(([elementId, key]) => {
                setupButton(elementId, key);
            });

            // Prevent page scrolling when touching the game area
            document.addEventListener('touchmove', (e) => {
                if (e.target.closest('.touch-controls')) {
                    e.preventDefault();
                }
            }, { passive: false });

            // Prevent context menu on long press
            document.addEventListener('contextmenu', (e) => {
                if (e.target.closest('.touch-controls')) {
                    e.preventDefault();
                }
            });

            // Add shoot button control
            const shootButton = document.getElementById('shoot-button');
            if (shootButton) {
                function pressShootButton(e) {
                    e.preventDefault();
                    shoot();
                    shootButton.style.background = 'rgba(255, 100, 100, 0.6)';
                    shootButton.style.transform = 'scale(0.95)';
                }

                function releaseShootButton(e) {
                    e.preventDefault();
                    shootButton.style.background = 'rgba(255, 100, 100, 0.4)';
                    shootButton.style.transform = 'scale(1)';
                }

                shootButton.addEventListener('touchstart', pressShootButton, { passive: false });
                shootButton.addEventListener('touchend', releaseShootButton, { passive: false });
                shootButton.addEventListener('mousedown', pressShootButton);
                shootButton.addEventListener('mouseup', releaseShootButton);
                shootButton.addEventListener('mouseleave', releaseShootButton);
            }
        }

        setupTouchControls();

        // Update camera far plane to see further
        camera.far = 3000;
        camera.updateProjectionMatrix();

        // After the bullet variables, add:
        const bullets = [];
        const explosions = [];  // Add this line
        const bulletSpeed = 3;
        const bulletLifetime = 1000;
        const shootingCooldown = 100;
        let lastShootTime = 0;

        // After the bullet variables, add sound setup
        const audioListener = new THREE.AudioListener();
        camera.add(audioListener);

        // Load explosion sound
        const explosionSound = new Audio('https://assets.mixkit.co/active_storage/sfx/2285/2285-preview.mp3');
        explosionSound.volume = 0.4;

        // After the audio setup, add bullet geometry and material
        const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
        const bulletMaterial = new THREE.MeshPhongMaterial({
            color: 0xffff00,
            emissive: 0xff8800
        });

        // Increase detection radius for more reliable hits
        const explosionRadius = 50;  // Much bigger radius
        const planeCollisionRadius = 20;  // Bigger plane collision radius

        // Simplified explosion variables
        const explosionDuration = 500;  // Shorter duration
        const explosionParticleCount = 8;  // Much fewer particles
        const explosionForce = 4;

        // Simpler particle geometry
        const particleGeometry = new THREE.BoxGeometry(1, 1, 1);
        const particleMaterial = new THREE.MeshPhongMaterial({
            color: 0xff4400,
            emissive: 0xff2200
        });

        // Replace explosion sound with synth bass
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playExplosionSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(30, audioContext.currentTime + 0.2);
            
            gainNode.gain.setValueAtTime(1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.2);
        }

        // Enhanced explosion effects
        function createCrazyExplosion(position) {
            playExplosionSound();
            
            // Main explosion
            const explosion = new THREE.Group();
            explosion.position.copy(position);
            
            // Multiple particle types
            const particleTypes = [
                { geometry: new THREE.BoxGeometry(2, 2, 2), color: 0xff4400, count: 20 },
                { geometry: new THREE.SphereGeometry(1, 8, 8), color: 0xff8800, count: 15 },
                { geometry: new THREE.TetrahedronGeometry(1), color: 0xffaa00, count: 15 }
            ];

            particleTypes.forEach(type => {
                const material = new THREE.MeshPhongMaterial({
                    color: type.color,
                    emissive: type.color,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });

                for (let i = 0; i < type.count; i++) {
                    const particle = new THREE.Mesh(type.geometry, material.clone());
                    particle.scale.multiplyScalar(1 + Math.random());
                    
                    // More dramatic velocities
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    particle.velocity = new THREE.Vector3(
                        Math.cos(angle) * speed,
                        Math.random() * speed * 2,
                        Math.sin(angle) * speed
                    );
                    
                    // Add rotation
                    particle.rotationSpeed = {
                        x: (Math.random() - 0.5) * 0.2,
                        y: (Math.random() - 0.5) * 0.2,
                        z: (Math.random() - 0.5) * 0.2
                    };
                    
                    explosion.add(particle);
                }
            });

            // Add shockwave effect
            const shockwaveGeometry = new THREE.RingGeometry(0.1, 1, 32);
            const shockwaveMaterial = new THREE.MeshBasicMaterial({
                color: 0xff8800,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
            shockwave.rotation.x = -Math.PI / 2;
            shockwave.scale.set(1, 1, 1);
            explosion.add(shockwave);

            scene.add(explosion);
            explosions.push(explosion);

            // Animate explosion
            const startTime = Date.now();
            explosion.tick = function() {
                const age = Date.now() - startTime;
                if (age > 2000) {
                    scene.remove(explosion);
                    const index = explosions.indexOf(explosion);
                    if (index > -1) explosions.splice(index, 1);
                    return;
                }

                // Update particles
                explosion.children.forEach(particle => {
                    if (particle.velocity) {
                        particle.position.add(particle.velocity);
                        particle.velocity.y -= 0.1;  // Gravity
                        
                        // Rotate particles
                        if (particle.rotationSpeed) {
                            particle.rotation.x += particle.rotationSpeed.x;
                            particle.rotation.y += particle.rotationSpeed.y;
                            particle.rotation.z += particle.rotationSpeed.z;
                        }
                        
                        // Fade out
                        if (particle.material.opacity > 0) {
                            particle.material.opacity -= 0.01;
                        }
                    } else if (particle.geometry instanceof THREE.RingGeometry) {
                        // Animate shockwave
                        const scale = 1 + age * 0.02;
                        particle.scale.set(scale, scale, scale);
                        particle.material.opacity = Math.max(0, 0.5 - age * 0.0005);
                    }
                });
            };
        }

        // Optimize collision detection
        const collisionCheckInterval = 100; // Check every 100ms
        let lastCollisionCheck = 0;

        // Fix propeller rotation variables
        const propellerSpeed = 0.2;  // Reduced base speed
        const minPropellerSpeed = 0.1;  // Minimum speed when idle
        const maxPropellerSpeed = 0.8;  // Maximum speed at full throttle
        let propellerRotation = 0;

        // Create birds with larger size
        function createBird() {
            const bird = new THREE.Group();
            
            // Bird body - bigger and more visible
            const body = new THREE.Mesh(
                new THREE.ConeGeometry(2, 8, 4),  // Much bigger body
                new THREE.MeshPhongMaterial({ 
                    color: 0x222222,  // Darker color
                    shininess: 30 
                })
            );
            body.rotation.x = Math.PI / 2;
            bird.add(body);
            
            // Wings - larger wingspan
            const wingGeometry = new THREE.BoxGeometry(16, 0.3, 4);  // Much wider wings
            const wingMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x222222,
                shininess: 30
            });
            
            const wings = new THREE.Mesh(wingGeometry, wingMaterial);
            wings.position.y = 1;  // Raised slightly
            bird.add(wings);
            
            // Add animation properties
            bird.wingAngle = 0;
            bird.speed = 1 + Math.random();  // Faster speed
            bird.turnRate = (Math.random() - 0.5) * 0.02;
            bird.yaw = Math.random() * Math.PI * 2;
            
            return bird;
        }

        // Adjust bird placement
        const birds = new THREE.Group();
        const birdCount = 30;  // Fewer birds but bigger
        const birdArea = 1000;
        const minBirdHeight = 150;  // Higher minimum height
        const maxBirdHeight = 400;  // Higher maximum height

        for (let i = 0; i < birdCount; i++) {
            const bird = createBird();
            bird.position.set(
                (Math.random() - 0.5) * birdArea,
                minBirdHeight + Math.random() * (maxBirdHeight - minBirdHeight),
                (Math.random() - 0.5) * birdArea
            );
            birds.add(bird);
        }
        scene.add(birds);

        // Add engine sound setup with deeper bass
        const engineSound = {
            oscillator: null,
            oscillator2: null,  // Second oscillator for bass
            oscillator3: null,  // Third oscillator for sub-bass
            gainNode: null,
            gainNode2: null,
            gainNode3: null,
            filterNode: null,
            isPlaying: false,
            
            start() {
                if (this.isPlaying) return;
                
                // Main oscillator (mid frequencies)
                this.oscillator = audioContext.createOscillator();
                this.gainNode = audioContext.createGain();
                this.filterNode = audioContext.createBiquadFilter();
                
                // Bass oscillator
                this.oscillator2 = audioContext.createOscillator();
                this.gainNode2 = audioContext.createGain();
                this.filterNode2 = audioContext.createBiquadFilter();
                
                // Sub-bass oscillator
                this.oscillator3 = audioContext.createOscillator();
                this.gainNode3 = audioContext.createGain();
                
                // Set up main sound
                this.oscillator.type = 'sawtooth';
                this.filterNode.type = 'lowpass';
                this.filterNode.frequency.value = 200;  // Lower cutoff
                this.gainNode.gain.value = 0.1;
                
                // Set up bass sound
                this.oscillator2.type = 'sine';
                this.filterNode2.type = 'lowpass';
                this.filterNode2.frequency.value = 100;
                this.gainNode2.gain.value = 0.2;
                
                // Set up sub-bass
                this.oscillator3.type = 'sine';
                this.gainNode3.gain.value = 0.3;
                
                // Connect nodes
                this.oscillator.connect(this.filterNode);
                this.filterNode.connect(this.gainNode);
                this.gainNode.connect(audioContext.destination);
                
                this.oscillator2.connect(this.filterNode2);
                this.filterNode2.connect(this.gainNode2);
                this.gainNode2.connect(audioContext.destination);
                
                this.oscillator3.connect(this.gainNode3);
                this.gainNode3.connect(audioContext.destination);
                
                // Start all oscillators
                this.oscillator.start();
                this.oscillator2.start();
                this.oscillator3.start();
                this.isPlaying = true;
            },
            
            stop() {
                if (!this.isPlaying) return;
                
                const stopTime = audioContext.currentTime + 0.1;
                this.gainNode.gain.linearRampToValueAtTime(0, stopTime);
                this.gainNode2.gain.linearRampToValueAtTime(0, stopTime);
                this.gainNode3.gain.linearRampToValueAtTime(0, stopTime);
                
                this.oscillator.stop(stopTime);
                this.oscillator2.stop(stopTime);
                this.oscillator3.stop(stopTime);
                this.isPlaying = false;
            },
            
            update(throttle, speed) {
                if (!this.isPlaying) return;
                
                // Base frequencies
                const mainFreq = 40 + (throttle * 30) + (speed * 0.2);
                const bassFreq = mainFreq * 0.5;
                const subFreq = mainFreq * 0.25;
                
                // Update frequencies
                this.oscillator.frequency.setTargetAtTime(mainFreq, audioContext.currentTime, 0.1);
                this.oscillator2.frequency.setTargetAtTime(bassFreq, audioContext.currentTime, 0.1);
                this.oscillator3.frequency.setTargetAtTime(subFreq, audioContext.currentTime, 0.1);
                
                // Update filter
                this.filterNode.frequency.setTargetAtTime(100 + (throttle * 200), audioContext.currentTime, 0.1);
                this.filterNode2.frequency.setTargetAtTime(50 + (throttle * 100), audioContext.currentTime, 0.1);
                
                // Update volumes
                const mainVol = 0.1 + (throttle * 0.1);
                const bassVol = 0.2 + (throttle * 0.2);
                const subVol = 0.3 + (throttle * 0.2);
                
                this.gainNode.gain.setTargetAtTime(mainVol, audioContext.currentTime, 0.1);
                this.gainNode2.gain.setTargetAtTime(bassVol, audioContext.currentTime, 0.1);
                this.gainNode3.gain.setTargetAtTime(subVol, audioContext.currentTime, 0.1);
            }
        };

        // Start engine sound when throttle is first applied
        let engineStarted = false;

        // Add FPS calculation variables
        let frameCount = 0;
        let lastFPSUpdate = Date.now();
        const fpsUpdateInterval = 1000; // Update FPS every second

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Calculate FPS
            frameCount++;
            const currentTime = Date.now();  // Changed from 'now' to 'currentTime'
            if (currentTime - lastFPSUpdate > fpsUpdateInterval) {
                const fps = Math.round((frameCount * 1000) / (currentTime - lastFPSUpdate));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastFPSUpdate = currentTime;
            }

            // Handle throttle
            if (keys['w'] || keys['W']) {
                throttle = Math.min(throttle + 0.02, 1);
            } else if (keys['s'] || keys['S']) {
                throttle = Math.max(throttle - 0.02, 0);
            }

            // Handle pitch
            if (keys['ArrowDown']) {  // Pull back (nose up)
                if (isAirborne || speed >= takeoffSpeed * 0.8) {
                    pitch = Math.min(pitch + pitchRate, Math.PI / 4);
                }
            } else if (keys['ArrowUp']) {  // Push forward (nose down)
                if (isAirborne) {
                    pitch = Math.max(pitch - pitchRate, -Math.PI / 4);
                }
            } else {
                pitch *= 0.95;  // Return to level
            }

            // Handle turning
            if (keys['ArrowLeft']) {
                if (isAirborne) {
                    roll = Math.min(roll + rollRate, Math.PI / 3);
                }
                yaw += turnRate * (isAirborne ? Math.abs(roll) * 0.5 : 1);
            } else if (keys['ArrowRight']) {
                if (isAirborne) {
                    roll = Math.max(roll - rollRate, -Math.PI / 3);
                }
                yaw -= turnRate * (isAirborne ? Math.abs(roll) * 0.5 : 1);
            } else {
                roll *= 0.95;  // Return to level
            }

            // Update speed
            if (!isAirborne) {
                // Ground movement
                if (throttle > 0) {
                    speed += throttle * acceleration;
                } else {
                    speed = Math.max(0, speed - deceleration);
                }
                speed = Math.min(speed, maxGroundSpeed);
            } else {
                // Air movement
                speed = Math.max(0, Math.min(maxAirSpeed, speed + (throttle - 0.5) * acceleration));
            }

            // Check for takeoff
            if (!isAirborne && speed >= takeoffSpeed && pitch > 0.1) {
                isAirborne = true;
                if (takeoffMessage) {
                    takeoffMessage.style.display = 'block';
                    if (takeoffMessageTimer) clearTimeout(takeoffMessageTimer);
                    takeoffMessageTimer = setTimeout(() => {
                        takeoffMessage.style.display = 'none';
                    }, 2000);
                }
            }

            // Update altitude with more gradual changes
            if (isAirborne) {
                // More gradual altitude changes
                const liftForce = (pitch * speed * liftRate);
                const verticalSpeed = liftForce - gravity;
                altitude += verticalSpeed;
                
                // Prevent sudden drops
                if (altitude <= 0) {
                    altitude = 0;
                    isAirborne = false;
                    speed *= 0.8;  // Reduce speed on landing
                }
            } else {
                altitude = 0;
            }

            // Update airplane position and rotation
            airplane.position.y = altitude;
            airplane.rotation.x = pitch;
            airplane.rotation.z = roll;
            airplane.rotation.y = yaw;

            const movement = speed * 0.01;
            airplane.position.x -= Math.sin(yaw) * movement;
            airplane.position.z -= Math.cos(yaw) * movement;

            // Update camera to follow from behind
            const cameraDistance = 5;
            camera.position.x = airplane.position.x + Math.sin(yaw) * cameraDistance;  // Changed minus to plus
            camera.position.z = airplane.position.z + Math.cos(yaw) * cameraDistance;  // Changed minus to plus
            camera.position.y = airplane.position.y + 2;
            camera.lookAt(airplane.position);

            // Update skybox position to follow camera
            skybox.position.copy(camera.position);

            // Move clouds slowly
            clouds.children.forEach((cloud, index) => {
                cloud.position.x += Math.sin(Date.now() * 0.0001 + index) * 0.1;
                cloud.position.z += Math.cos(Date.now() * 0.0001 + index) * 0.1;
                
                // Wrap clouds around when they go too far
                const halfCloudArea = cloudArea / 2;
                if (cloud.position.x > halfCloudArea) cloud.position.x = -halfCloudArea;
                if (cloud.position.x < -halfCloudArea) cloud.position.x = halfCloudArea;
                if (cloud.position.z > halfCloudArea) cloud.position.z = -halfCloudArea;
                if (cloud.position.z < -halfCloudArea) cloud.position.z = halfCloudArea;
                
                // Slowly rotate clouds
                cloud.rotation.y += 0.001;
            });

            // Update bullets and check collisions
            const now = Date.now();
            if (now - lastCollisionCheck > collisionCheckInterval) {
                lastCollisionCheck = now;
                
                // Check building collisions less frequently
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    for (let j = buildings.length - 1; j >= 0; j--) {
                        const building = buildings[j];
                        const distance = bullet.position.distanceTo(building.position);
                        if (distance < explosionRadius) {
                            createCrazyExplosion(building.position);
                            scene.remove(building);
                            buildings.splice(j, 1);
                            scene.remove(bullet);
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                }
            }

            // Update bullet positions
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.position.x += bullet.velocity.x;
                bullet.position.y += bullet.velocity.y;
                bullet.position.z += bullet.velocity.z;

                // Remove old bullets
                if (now - bullet.createdAt > bulletLifetime) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }

            // Update propeller rotation - more realistic speed
            if (!isAirborne) {
                // Slower on ground
                propellerRotation += (throttle * propellerSpeed + minPropellerSpeed);
            } else {
                // Faster in air, based on speed
                propellerRotation += Math.min(
                    maxPropellerSpeed,
                    (throttle * propellerSpeed + minPropellerSpeed) * (1 + speed/100)
                );
            }
            propeller.rotation.z = propellerRotation;

            // Update birds
            birds.children.forEach((bird, index) => {
                // Flap wings
                bird.wingAngle += 0.2;
                bird.children[1].rotation.z = Math.sin(bird.wingAngle) * 0.3;
                
                // Move bird
                bird.yaw += bird.turnRate;
                bird.position.x += Math.sin(bird.yaw) * bird.speed;
                bird.position.z += Math.cos(bird.yaw) * bird.speed;
                bird.rotation.y = bird.yaw;
                
                // Wrap birds around when they go too far
                const halfBirdArea = birdArea / 2;
                if (bird.position.x > halfBirdArea) bird.position.x = -halfBirdArea;
                if (bird.position.x < -halfBirdArea) bird.position.x = halfBirdArea;
                if (bird.position.z > halfBirdArea) bird.position.z = -halfBirdArea;
                if (bird.position.z < -halfBirdArea) bird.position.z = halfBirdArea;
            });

            // Update HUD
            document.getElementById('speed').textContent = Math.round(speed);
            document.getElementById('altitude').textContent = Math.round(altitude);

            // Update engine sound
            if (throttle > 0 && !engineStarted) {
                engineSound.start();
                engineStarted = true;
            } else if (throttle === 0 && engineStarted) {
                engineSound.stop();
                engineStarted = false;
            }
            
            if (engineStarted) {
                engineSound.update(throttle, speed);
            }

            // Update explosions
            explosions.forEach(explosion => {
                if (explosion.tick) explosion.tick();
            });

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

        // Add shooting function
        function shoot() {
            const now = Date.now();
            if (now - lastShootTime < shootingCooldown) return;
            lastShootTime = now;

            // Play blaster sound
            createBlasterSound();

            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.position.copy(airplane.position);
            bullet.rotation.copy(airplane.rotation);
            bullet.createdAt = now;
            
            // Fix bullet velocity to shoot forward from plane's direction
            bullet.velocity = {
                x: -Math.sin(yaw) * bulletSpeed,  // Add back negative sign
                y: Math.sin(pitch) * bulletSpeed,
                z: -Math.cos(yaw) * bulletSpeed   // Add back negative sign
            };
            
            scene.add(bullet);
            bullets.push(bullet);
        }

        // Make sure Space key handler is properly set up
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.code === 'Space' || e.key === ' ') {  // Handle both Space and spacebar
                shoot();
            }
        });

        // Add blaster sound setup
        function createBlasterSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filterNode = audioContext.createBiquadFilter();

            // Set up sci-fi blaster characteristics
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(1000, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.1);

            filterNode.type = 'bandpass';
            filterNode.frequency.setValueAtTime(1000, audioContext.currentTime);
            filterNode.Q.value = 10;

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

            // Connect nodes
            oscillator.connect(filterNode);
            filterNode.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Start and stop
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // Create human figure
        function createHuman() {
            const human = new THREE.Group();
            
            // Body
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 1.2, 8),
                new THREE.MeshPhongMaterial({ color: 0x333333 })
            );
            body.position.y = 0.6;
            human.add(body);
            
            // Head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 8, 8),
                new THREE.MeshPhongMaterial({ color: 0xffdbac })
            );
            head.position.y = 1.4;
            human.add(head);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6, 8);
            const legMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(0.1, 0.3, 0);
            human.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(-0.1, 0.3, 0);
            human.add(rightLeg);
            
            // Animation properties
            human.walkAngle = Math.random() * Math.PI * 2;
            human.walkSpeed = 0.05 + Math.random() * 0.05;
            human.direction = Math.random() * Math.PI * 2;
            human.nextDirectionChange = Date.now() + Math.random() * 5000;
            
            return human;
        }

        // Add humans to scene
        const humans = [];
        const humanCount = 50;
        const humanArea = 1000;

        for (let i = 0; i < humanCount; i++) {
            const human = createHuman();
            human.position.set(
                (Math.random() - 0.5) * humanArea,
                0,
                (Math.random() - 0.5) * humanArea
            );
            humans.push(human);
            scene.add(human);
        }

        // In the animation loop, add:
        // Update humans
        humans.forEach(human => {
            // Walking animation
            human.walkAngle += 0.1;
            human.children[2].position.y = 0.3 + Math.sin(human.walkAngle) * 0.1;  // Left leg
            human.children[3].position.y = 0.3 + Math.sin(human.walkAngle + Math.PI) * 0.1;  // Right leg
            
            // Movement
            const now = Date.now();
            if (now > human.nextDirectionChange) {
                human.direction += (Math.random() - 0.5) * Math.PI / 2;
                human.nextDirectionChange = now + Math.random() * 5000;
            }
            
            human.position.x += Math.sin(human.direction) * human.walkSpeed;
            human.position.z += Math.cos(human.direction) * human.walkSpeed;
            human.rotation.y = human.direction;
            
            // Keep humans within bounds
            const halfArea = humanArea / 2;
            if (human.position.x > halfArea) human.position.x = -halfArea;
            if (human.position.x < -halfArea) human.position.x = halfArea;
            if (human.position.z > halfArea) human.position.z = -halfArea;
            if (human.position.z < -halfArea) human.position.z = halfArea;
        });

        // Create pyramid
        function createPyramid() {
            const pyramid = new THREE.Group();
            
            // Main pyramid body
            const pyramidGeometry = new THREE.ConeGeometry(150, 200, 4);
            const pyramidMaterial = new THREE.MeshPhongMaterial({
                color: 0xD2B48C,  // Sandy color
                flatShading: true
            });
            const pyramidBody = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
            pyramidBody.position.y = 100;
            pyramidBody.castShadow = true;
            pyramidBody.receiveShadow = true;
            pyramid.add(pyramidBody);

            // Add stone blocks texture effect
            const blockSize = 10;
            const blocksCount = 20;
            
            for (let i = 0; i < blocksCount; i++) {
                for (let j = 0; j < blocksCount - i; j++) {
                    const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize/2, blockSize);
                    const blockMaterial = new THREE.MeshPhongMaterial({
                        color: new THREE.Color(
                            0.8 + Math.random() * 0.2,
                            0.7 + Math.random() * 0.2,
                            0.5 + Math.random() * 0.2
                        )
                    });
                    const block = new THREE.Mesh(blockGeometry, blockMaterial);
                    
                    // Position blocks in a pyramid pattern
                    const y = i * (blockSize/2);
                    const offset = (j - (blocksCount - i)/2) * blockSize;
                    block.position.set(offset, y, offset);
                    block.castShadow = true;
                    block.receiveShadow = true;
                    
                    pyramid.add(block);
                }
            }

            // Add entrance
            const entranceGeometry = new THREE.BoxGeometry(20, 30, 20);
            const entranceMaterial = new THREE.MeshPhongMaterial({
                color: 0x000000
            });
            const entrance = new THREE.Mesh(entranceGeometry, entranceMaterial);
            entrance.position.set(0, 10, 150);
            pyramid.add(entrance);

            // Add steps leading to entrance
            const stepsCount = 10;
            const stepWidth = 40;
            const stepHeight = 2;
            
            for (let i = 0; i < stepsCount; i++) {
                const stepGeometry = new THREE.BoxGeometry(
                    stepWidth - (i * 2),
                    stepHeight,
                    stepWidth/4
                );
                const stepMaterial = new THREE.MeshPhongMaterial({
                    color: 0xD2B48C
                });
                const step = new THREE.Mesh(stepGeometry, stepMaterial);
                step.position.set(
                    0,
                    i * stepHeight,
                    150 - (stepWidth/8) * (stepsCount - i)
                );
                step.castShadow = true;
                step.receiveShadow = true;
                pyramid.add(step);
            }

            return pyramid;
        }

        // Add pyramid to scene
        const pyramid = createPyramid();
        pyramid.position.set(-500, 0, -500);  // Same position as old volcano
        pyramid.rotation.y = Math.PI / 4;  // Rotate 45 degrees for better view
        scene.add(pyramid);
    </script>
</body>
</html> 