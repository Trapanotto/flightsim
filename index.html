<!DOCTYPE html>
<html>
<head>
    <title>Simple Flight Simulator</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            line-height: 1.4;
        }
        .touch-controls {
            position: fixed;
            pointer-events: none;
        }
        .touch-button {
            width: 80px;
            height: 80px;
            background: rgba(255,255,255,0.4);
            border: 2px solid white;
            border-radius: 50%;
            color: white;
            font-size: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            pointer-events: auto;
            cursor: pointer;
            touch-action: none;
        }
        #throttle-controls {
            position: fixed;
            right: 40px;
            bottom: 40px;
        }
        #direction-controls {
            position: fixed;
            left: 40px;
            bottom: 40px;
        }
        /* Specific button positions for direction controls */
        #pitch-up {
            position: absolute;
            bottom: 160px;
            left: 80px;
        }
        
        #turn-left {
            position: absolute;
            bottom: 80px;
            left: 0;
        }
        
        #turn-right {
            position: absolute;
            bottom: 80px;
            left: 160px;
        }
        
        #pitch-down {
            position: absolute;
            bottom: 0;
            left: 80px;
        }
        
        /* Specific button positions for throttle controls */
        #throttle-up {
            position: absolute;
            bottom: 120px;
            right: 40px;
        }
        
        #throttle-down {
            position: absolute;
            bottom: 20px;
            right: 40px;
        }
        @media (max-width: 768px) {
            .touch-button {
                width: 65px;
                height: 65px;
                font-size: 26px;
            }
            /* Adjust positions for smaller screens */
            #pitch-up { 
                bottom: 130px;
                left: 65px;
            }
            #turn-left {
                bottom: 65px;
                left: 0;
            }
            #turn-right {
                bottom: 65px;
                left: 130px;
            }
            #pitch-down {
                bottom: 0;
                left: 65px;
            }
            #throttle-up {
                bottom: 100px;
                right: 30px;
            }
            #throttle-down {
                bottom: 15px;
                right: 30px;
            }
        }
        @media (max-width: 480px) {
            .touch-button {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            /* Adjust positions for mobile screens */
            #pitch-up {
                bottom: 100px;
                left: 50px;
            }
            #turn-left {
                bottom: 50px;
                left: 0;
            }
            #turn-right {
                bottom: 50px;
                left: 100px;
            }
            #pitch-down {
                bottom: 0;
                left: 50px;
            }
            #throttle-up {
                bottom: 80px;
                right: 20px;
            }
            #throttle-down {
                bottom: 10px;
                right: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="hud">
        Speed: <span id="speed">0</span> km/h<br>
        Altitude: <span id="altitude">0</span> m<br>
        <br>
        Controls:<br>
        W/S - Throttle Up/Down<br>
        ↑/↓ - Pitch (pull back/DOWN to take off)<br>
        ←/→ - Turn Left/Right (Roll when airborne)<br>
        <div id="takeoff-message" style="display: none; color: #ff0; font-size: 1.2em; margin-top: 10px; font-weight: bold;">TAKEOFF</div>
    </div>
    <div id="throttle-controls" class="touch-controls">
        <div class="touch-button" id="throttle-up">W</div>
        <div class="touch-button" id="throttle-down">S</div>
    </div>
    <div id="direction-controls" class="touch-controls">
        <div class="touch-button" id="pitch-up">↑</div>
        <div class="touch-button" id="turn-left">←</div>
        <div class="touch-button" id="turn-right">→</div>
        <div class="touch-button" id="pitch-down">↓</div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Initialize Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create airplane with more visible parts
        const airplane = new THREE.Group();
        
        // Fuselage
        const fuselage = new THREE.Mesh(
            new THREE.BoxGeometry(1, 0.8, 4),  // Made longer and taller
            new THREE.MeshPhongMaterial({ color: 0x3366cc })  // Blue color
        );
        
        // Main wing
        const wing = new THREE.Mesh(
            new THREE.BoxGeometry(7, 0.2, 1.5),  // Made wider
            new THREE.MeshPhongMaterial({ color: 0x3366cc })
        );
        wing.position.y = 0.1;  // Slightly above center
        
        // Tail wing
        const tailWing = new THREE.Mesh(
            new THREE.BoxGeometry(2, 0.2, 0.8),
            new THREE.MeshPhongMaterial({ color: 0x3366cc })
        );
        tailWing.position.z = -1.8;  // Place at back
        tailWing.position.y = 0.3;   // Higher than main wing
        
        // Vertical stabilizer
        const verticalStab = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 1, 1),
            new THREE.MeshPhongMaterial({ color: 0x3366cc })
        );
        verticalStab.position.z = -1.8;
        verticalStab.position.y = 0.5;

        airplane.add(fuselage);
        airplane.add(wing);
        airplane.add(tailWing);
        airplane.add(verticalStab);
        scene.add(airplane);

        // Create runway (larger and more visible)
        const runway = new THREE.Group();
        
        // Main runway strip
        const runwayStrip = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 200),
            new THREE.MeshPhongMaterial({ color: 0x444444 }) // Dark gray
        );
        runwayStrip.rotation.x = -Math.PI / 2;
        runway.add(runwayStrip);

        // Runway markings
        const markingMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
        for (let i = -90; i <= 90; i += 20) {
            const marking = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 10),
                markingMaterial
            );
            marking.rotation.x = -Math.PI / 2;
            marking.position.z = i;
            marking.position.y = 0.01; // Slightly above runway to prevent z-fighting
            runway.add(marking);
        }
        
        runway.position.z = 20;
        scene.add(runway);

        // Create flat ground
        const groundGeometry = new THREE.PlaneGeometry(4000, 4000);
        const ground = new THREE.Mesh(
            groundGeometry,
            new THREE.MeshPhongMaterial({ 
                color: 0x228B22,
                flatShading: true 
            })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.1;
        scene.add(ground);

        // Create skybox with larger size
        const skyboxGeometry = new THREE.BoxGeometry(4000, 4000, 4000);
        const skyboxMaterials = [
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0x87CEEB), // Light blue
                side: THREE.BackSide 
            }),
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0x87CEEB),
                side: THREE.BackSide 
            }),
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0x4169E1), // Royal blue for top
                side: THREE.BackSide 
            }),
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0xADD8E6), // Light blue for bottom
                side: THREE.BackSide 
            }),
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0x87CEEB),
                side: THREE.BackSide 
            }),
            new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(0x87CEEB),
                side: THREE.BackSide 
            })
        ];
        
        const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
        scene.add(skybox);

        // Create clouds
        function createCloud() {
            const cloudGeometry = new THREE.SphereGeometry(15, 8, 8);
            const cloudMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                flatShading: true
            });

            const cloud = new THREE.Group();
            
            // Create random blob-like cloud shape
            for (let i = 0; i < 5 + Math.random() * 5; i++) {
                const blob = new THREE.Mesh(cloudGeometry, cloudMaterial);
                blob.position.set(
                    Math.random() * 20 - 10,
                    Math.random() * 10 - 5,
                    Math.random() * 20 - 10
                );
                blob.scale.set(
                    0.5 + Math.random() * 0.5,
                    0.5 + Math.random() * 0.3,
                    0.5 + Math.random() * 0.5
                );
                cloud.add(blob);
            }
            
            return cloud;
        }

        // Add clouds to scene
        const clouds = new THREE.Group();
        const cloudCount = 50;
        const cloudArea = 2000;  // Area where clouds can spawn
        const minCloudHeight = 200;
        const maxCloudHeight = 400;

        for (let i = 0; i < cloudCount; i++) {
            const cloud = createCloud();
            cloud.position.set(
                (Math.random() - 0.5) * cloudArea,
                minCloudHeight + Math.random() * (maxCloudHeight - minCloudHeight),
                (Math.random() - 0.5) * cloudArea
            );
            cloud.rotation.y = Math.random() * Math.PI * 2;
            clouds.add(cloud);
        }
        scene.add(clouds);

        // Fix building creation function
        function createBuilding(x, z, height) {
            const building = new THREE.Group();
            
            // Main building body
            const bodyGeometry = new THREE.BoxGeometry(
                10 + Math.random() * 10,
                height,
                10 + Math.random() * 10
            );
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color(
                    0.5 + Math.random() * 0.2,
                    0.5 + Math.random() * 0.2,
                    0.5 + Math.random() * 0.2
                )
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            
            // Windows
            const windowMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                emissive: 0x555555
            });
            
            for (let i = 1; i < height; i += 4) {
                for (let j = -1; j <= 1; j += 1) {
                    const window = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 2, 2),
                        windowMaterial
                    );
                    window.position.set(
                        bodyGeometry.parameters.width/2,
                        i - height/2,
                        j * 3
                    );
                    body.add(window);
                    
                    const window2 = window.clone();
                    window2.position.x = -bodyGeometry.parameters.width/2;
                    body.add(window2);
                }
            }
            
            building.add(body);
            building.position.set(x, height/2, z);  // Removed groundHeight
            return building;
        }

        // Add buildings to scene
        const cityArea = 1600;  // Doubled city area
        const buildingCount = 100;  // More buildings
        const minHeight = 30;
        const maxHeight = 150;
        
        for (let i = 0; i < buildingCount; i++) {
            const x = (Math.random() - 0.5) * cityArea;
            const z = (Math.random() - 0.5) * cityArea;
            
            // Don't place buildings near the runway
            if (Math.abs(x) > 50 || Math.abs(z) > 100) {
                const height = minHeight + Math.random() * (maxHeight - minHeight);
                const building = createBuilding(x, z, height);
                scene.add(building);
            }
        }

        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Camera position
        camera.position.set(0, 2, -5);
        camera.lookAt(airplane.position);

        // Physics variables
        let speed = 0;
        let altitude = 0;
        let pitch = 0;
        let roll = 0;
        let yaw = 0;
        let throttle = 0;
        let isAirborne = false;
        let takeoffMessageTimer = null;  // Add timer variable
        
        // Aircraft characteristics - simplified arcade style
        const maxGroundSpeed = 150;    // Max speed on ground
        const maxAirSpeed = 200;       // Max speed in air
        const takeoffSpeed = 60;       // Speed needed for takeoff
        const acceleration = 0.8;      // Ground acceleration
        const deceleration = 0.3;      // Ground deceleration
        const pitchRate = 0.015;       // Reduced pitch rate
        const rollRate = 0.02;         // Roll control sensitivity
        const turnRate = 0.02;         // Turn rate
        const gravity = 0.1;           // Reduced gravity
        const liftRate = 0.05;         // Reduced lift rate significantly

        // Controls
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        // Touch controls setup
        function setupTouchControls() {
            // Helper function for both touch and click events
            function setupButton(elementId, key) {
                const element = document.getElementById(elementId);
                if (!element) return;

                function pressButton(e) {
                    e.preventDefault();
                    keys[key] = true;
                    element.style.background = 'rgba(255,255,255,0.6)';
                    element.style.transform = 'scale(0.95)';
                }

                function releaseButton(e) {
                    e.preventDefault();
                    keys[key] = false;
                    element.style.background = 'rgba(255,255,255,0.4)';
                    element.style.transform = 'scale(1)';
                }

                // Touch events
                element.addEventListener('touchstart', pressButton, { passive: false });
                element.addEventListener('touchend', releaseButton, { passive: false });
                element.addEventListener('touchcancel', releaseButton, { passive: false });

                // Mouse events
                element.addEventListener('mousedown', pressButton);
                element.addEventListener('mouseup', releaseButton);
                element.addEventListener('mouseleave', releaseButton);

                // Prevent text selection
                element.addEventListener('selectstart', (e) => e.preventDefault());
            }

            // Setup each control
            const controls = [
                ['throttle-up', 'w'],
                ['throttle-down', 's'],
                ['pitch-up', 'ArrowUp'],
                ['pitch-down', 'ArrowDown'],
                ['turn-left', 'ArrowLeft'],
                ['turn-right', 'ArrowRight']
            ];

            controls.forEach(([elementId, key]) => {
                setupButton(elementId, key);
            });

            // Prevent page scrolling when touching the game area
            document.addEventListener('touchmove', (e) => {
                if (e.target.closest('.touch-controls')) {
                    e.preventDefault();
                }
            }, { passive: false });

            // Prevent context menu on long press
            document.addEventListener('contextmenu', (e) => {
                if (e.target.closest('.touch-controls')) {
                    e.preventDefault();
                }
            });
        }

        setupTouchControls();

        // Update camera far plane to see further
        camera.far = 3000;
        camera.updateProjectionMatrix();

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Handle throttle
            if (keys['w'] || keys['W']) {
                throttle = Math.min(throttle + 0.02, 1);
            } else if (keys['s'] || keys['S']) {
                throttle = Math.max(throttle - 0.02, 0);
            }

            // Handle pitch
            if (keys['ArrowDown']) {  // Pull back (nose up)
                if (isAirborne || speed >= takeoffSpeed * 0.8) {
                    pitch = Math.min(pitch + pitchRate, Math.PI / 4);
                }
            } else if (keys['ArrowUp']) {  // Push forward (nose down)
                if (isAirborne) {
                    pitch = Math.max(pitch - pitchRate, -Math.PI / 4);
                }
            } else {
                pitch *= 0.95;  // Return to level
            }

            // Handle turning
            if (keys['ArrowLeft']) {
                if (isAirborne) {
                    roll = Math.min(roll + rollRate, Math.PI / 3);
                }
                yaw += turnRate * (isAirborne ? Math.abs(roll) * 0.5 : 1);
            } else if (keys['ArrowRight']) {
                if (isAirborne) {
                    roll = Math.max(roll - rollRate, -Math.PI / 3);
                }
                yaw -= turnRate * (isAirborne ? Math.abs(roll) * 0.5 : 1);
            } else {
                roll *= 0.95;  // Return to level
            }

            // Update speed
            if (!isAirborne) {
                // Ground movement
                if (throttle > 0) {
                    speed += throttle * acceleration;
                } else {
                    speed = Math.max(0, speed - deceleration);
                }
                speed = Math.min(speed, maxGroundSpeed);
            } else {
                // Air movement
                speed = Math.max(0, Math.min(maxAirSpeed, speed + (throttle - 0.5) * acceleration));
            }

            // Check for takeoff
            if (!isAirborne && speed >= takeoffSpeed && pitch > 0.1) {
                isAirborne = true;
                if (takeoffMessage) {
                    takeoffMessage.style.display = 'block';
                    if (takeoffMessageTimer) clearTimeout(takeoffMessageTimer);
                    takeoffMessageTimer = setTimeout(() => {
                        takeoffMessage.style.display = 'none';
                    }, 2000);
                }
            }

            // Update altitude with more gradual changes
            if (isAirborne) {
                // More gradual altitude changes
                const liftForce = (pitch * speed * liftRate);
                const verticalSpeed = liftForce - gravity;
                altitude += verticalSpeed;
                
                // Prevent sudden drops
                if (altitude <= 0) {
                    altitude = 0;
                    isAirborne = false;
                    speed *= 0.8;  // Reduce speed on landing
                }
            } else {
                altitude = 0;
            }

            // Update airplane position and rotation
            airplane.position.y = altitude;
            airplane.rotation.x = pitch;
            airplane.rotation.z = roll;
            airplane.rotation.y = yaw;

            const movement = speed * 0.01;
            airplane.position.x -= Math.sin(yaw) * movement;
            airplane.position.z -= Math.cos(yaw) * movement;

            // Update camera to follow from behind
            const cameraDistance = 5;
            camera.position.x = airplane.position.x + Math.sin(yaw) * cameraDistance;  // Changed minus to plus
            camera.position.z = airplane.position.z + Math.cos(yaw) * cameraDistance;  // Changed minus to plus
            camera.position.y = airplane.position.y + 2;
            camera.lookAt(airplane.position);

            // Update skybox position to follow camera
            skybox.position.copy(camera.position);

            // Move clouds slowly
            clouds.children.forEach((cloud, index) => {
                cloud.position.x += Math.sin(Date.now() * 0.0001 + index) * 0.1;
                cloud.position.z += Math.cos(Date.now() * 0.0001 + index) * 0.1;
                
                // Wrap clouds around when they go too far
                const halfCloudArea = cloudArea / 2;
                if (cloud.position.x > halfCloudArea) cloud.position.x = -halfCloudArea;
                if (cloud.position.x < -halfCloudArea) cloud.position.x = halfCloudArea;
                if (cloud.position.z > halfCloudArea) cloud.position.z = -halfCloudArea;
                if (cloud.position.z < -halfCloudArea) cloud.position.z = halfCloudArea;
                
                // Slowly rotate clouds
                cloud.rotation.y += 0.001;
            });

            // Update HUD
            document.getElementById('speed').textContent = Math.round(speed);
            document.getElementById('altitude').textContent = Math.round(altitude);

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html> 